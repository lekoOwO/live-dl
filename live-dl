#!/bin/bash
#
# Live Downloader
# Download live streams from YouTube
#
# Tunghsiao Liu <t@sparanoid.com>
# Released under AGPL-3.0
#

#
# System reqirements
#
# - aria2c
# - bash
# - exiv2
# - ffmpeg
# - jq
# - streamlink
# - yt-dlp
# - yq (python-yq)
#

#
# Changelog
#
# Sep 23, 2019
# - First release
#

#
# To-do list
#
# - [x] dependencies check
# - [x] convert output from .ts to .mp4
# - [x] youtube playlist support (not perfect when writing metadata)
# - [x] thumbnail size check
# - [x] write metadata and cover
# - [x] email notification
# - [x] mailgun setup guide
# - [x] slack notification
# - [x] telegram notification
# - [ ] discord notification
# - [x] refine telegram multichannel support
# - [x] channel name mapping
# - [x] download base dir support
# - [ ] get channel avatar
# - [ ] upcoming streams detection
# - [ ] keyword filter
# - [ ] metadata overriding mode
# - [x] summary output for uploading
# - [x] recording summary
# - [x] embed cover
# - [x] add hostname to output
# - [ ] dockerize this script
# - [ ] bilibili live support
# - [ ] qq notification
# - [x] rewrite is_live detection logic
#

#
# Variables
#
# USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36"

# Dec 26 2020
# If User Agent is set to Chrome, jq parses it error.
USER_AGENT="live-dl"
IMAGE_PROXY_BASE="https://experiments.sparanoid.net/imageproxy/"

#
# Functions
#

# Text color helper borrowed from acme.sh
__green() {
  printf '\033[1;31;32m%b\033[0m' "$1"
}

__yellow() {
  printf '\033[1;31;33m%b\033[0m' "$1"
}

__red() {
  printf '\033[1;31;40m%b\033[0m' "$1"
}

__info() {
  printf "[$(date)] %s\n" "$1"
}

__debug() {
  DEBUG="${PARAM_DEBUG:-"false"}"
  if [ "$DEBUG" == "true" ]; then
    printf "[$(date)] DEBUG: %s\n" "$1"
  fi
}

# Convert secs to HH:MM:SS format
__convert_seconds() {
  # https://stackoverflow.com/a/39452629/412385
  printf '%02d:%02d:%02d\n' $(($1/3600)) $(($1%3600/60)) $(($1%60))
}

# Set the current working directory to the directory of this script
# http://stackoverflow.com/a/17744637/412385
cd ${0%/*}

# Prepare options
POSITIONAL=()
while [ $# -gt 0 ]; do
  key="$1"

  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -m|--mode)
      PARAM_MODE="$2"
      shift
      shift
      ;;
    -o|--output)
      PARAM_BASE_DIR="$2"
      shift
      shift
      ;;
    -i|--interval)
      PARAM_INTERVAL="$2"
      shift
      shift
      ;;
    --init)
      PARAM_INIT_SCRIPT=true
      shift
      ;;
    --debug)
      PARAM_DEBUG=true
      shift
      ;;
    -a|--create-alias)
      PARAM_CREATE_ALIAS=true
      shift
      ;;
    --skip-convert)
      PARAM_SKIP_CONVERT=true
      shift
      ;;
    --skip-recheck)
      PARAM_SKIP_RECHECK=true
      shift
      ;;
    --skip-metadata)
      PARAM_SKIP_METADATA=true
      shift
      ;;
    --skip-email)
      PARAM_SKIP_EMAIL=true
      shift
      ;;
    --skip-slack)
      PARAM_SKIP_SLACK=true
      shift
      ;;
    --skip-telegram)
      PARAM_SKIP_TELEGRAM=true
      shift
      ;;
    --callback)
      PARAM_CALLBACK=true
      PARAM_CALLBACK_EXEC="$2"
      shift
      shift
      ;;
    --onlive)
      PARAM_ONLIVE=true
      PARAM_ONLIVE_EXEC="$2"
      shift
      shift
      ;;
    --ytarchive)
      PARAM_YTARCHIVE=true
      PARAM_YTARCHIVE_EXEC="$2"
      shift
      shift
      ;;
    --ytarchive-cookie)
      PARAM_YTARCHIVE=true
      PARAM_YTARCHIVE_COOKIE="$2"
      shift
      shift
      ;;
    --address-pool)
      PARAM_ADDRESS_POOL=true
      PARAM_ADDRESS_POOL_FILE="$2"
      shift
      shift
      ;;
    -1|--once)
      PARAM_ONE_TIME=true
      shift
      ;;
    --image-proxy)
      PARAM_IMAGE_PROXY=true
      shift
      ;;
    *) # other unknown options
      POSITIONAL+=("$1") # save it in an array for later
      shift
      ;;
  esac
done

# restore positional parameters
set -- "${POSITIONAL[@]}"

# Install repo for CentOS/RHEL
function func_add_repo_rhel() {
  rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro
  rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm
}

# Check dependencies
function func_check_deps() {
  __info "Checking dependencies..."

  if command -v ffmpeg >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(ffmpeg -version | head -n 1)"
  else
    __info "FFmpeg not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        func_add_repo_rhel
        yum install ffmpeg -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install ffmpeg -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install ffmpeg
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v yt-dlp >/dev/null 2>&1 ; then
    __info "$(__green "Found"): yt-dlp $(yt-dlp --version | head -n 1)"
  else
    __info "yt-dlp not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      pip install yt-dlp
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install ffmpeg
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v jq >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(jq --version | head -n 1)"
  else
    __info "jq not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        yum install jq -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install jq -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install jq
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v yq >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(yq --version | head -n 1)"
  else
    __info "yq not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        pip install yq
      fi
      if [ -f /etc/lsb-release ]; then
        apt install python-pip
        pip install yq
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install python-yq
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v exiv2 >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(exiv2 --version | head -n 1)"
  else
    __info "exiv2 not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install exiv2 -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install exiv2 -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install exiv2
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v aria2c >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(aria2c -v | head -n 1)"
  else
    __info "aria2 not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        yum install epel-release -y
        yum install aria2 -y
      fi
      if [ -f /etc/lsb-release ]; then
        apt-get install aria2 -y
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install aria2
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  if command -v streamlink >/dev/null 2>&1 ; then
    __info "$(__green "Found"): $(streamlink --version | head -n 1)"
  else
    __info "streamlink not found, trying to install..."
    if [ "$OSTYPE" == "linux-gnu" ]; then
      if [ -f /etc/redhat-release ]; then
        pip install streamlink
      fi
      if [ -f /etc/lsb-release ]; then
        add-apt-repository ppa:nilarimogard/webupd8
        apt install streamlink
      fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      brew install streamlink
    else
      __info "No platform/architecture supported, please install it manually."
    fi
  fi

  # Check if we need to create alias
  CREATE_ALIAS="${PARAM_CREATE_ALIAS:-"false"}"
  if [ "$CREATE_ALIAS" == "true" ]; then
    __info "Creating alias..."
    _profile="$(func_detect_profile)"
    _cwd="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
    _alias="alias live-dl='$_cwd/live-dl'"
    grep -qxF "$_alias" "$_profile" || echo "$_alias" >> "$_profile"
  fi
}

function func_create_url() {
  # Create correct URL/URI based on user input
  #
  # https://www.youtube.com/channel/UCxRuOqAAVo-f516Gygjh_wA/live
  # https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/watch?v=S3CAGeeMRvo
  # https://www.youtube.com/playlist?list=UU1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/feed/subscriptions
  # https://live.bilibili.com/14917277
  # https://live.bilibili.com/456117
  #

  local _url=$1

  if [[ "$_url" =~ "youtube.com" ]]; then
    __info "YouTube URL detected"
    DL_PLATFORM="YouTube"

    if [[ "$_url" =~ "/channel" && "$_url" =~ "/live" ]]; then
      __info "YouTube channel detected"
      DL_URL="$_url"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/channel" && ! "$_url" =~ "/live" ]]; then
      __info "YouTube video detected (alt)"
      DL_URL="$_url/live"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/watch"* ]]; then
      __info "YouTube video detected"
      DL_URL="$_url"
      DL_TYPE="video"

    elif [[ "$_url" =~ "/playlist"* ]]; then
      __info "YouTube playlist detected"
      DL_URL="$_url"
      DL_TYPE="playlist"

    else
      __info "$(__red "Non-supported YouTube URL")"
      exit 1
    fi

  elif [[ "$_url" =~ "live.bilibili.com" ]]; then
    __info "Bilibili detected"
    DL_URL="$_url"
    DL_PLATFORM="bilibili"

  else
    if [[ ! "$_url" == "http"* ]]; then
      __info "$(__yellow "URI detected, guessing... (Use full URL to avoid guessing URL)")"

      if [[ "$_url" =~ ^([0-9]+)$ ]]; then
        __info "Bilibili room ID detected"
        DL_URL="https://live.bilibili.com/$_url"
        DL_PLATFORM="bilibili"

      # if URI is longer than 11 (11 is the length of YouTube video ID)
      elif [[ ${#_url} -ge 12 ]]; then
        __info "YouTube channel ID detected"
        DL_URL="https://www.youtube.com/channel/$_url/live"
        DL_PLATFORM="YouTube"
        DL_TYPE="channel"

      else
        __info "YouTube video ID detected"
        DL_URL="https://www.youtube.com/watch?v=$_url"
        DL_PLATFORM="YouTube"
        DL_TYPE="video"
      fi

    else
      __info "$(__red "Non-supported URL")"
      exit 1
    fi
  fi
}

function func_gen_curl_address_param() {
  if [[ "$ADDRESS_POOL" == "true" && "$ADDRESS_POOL_FILE" != "/dev/null" ]]; then
    local ip=$(shuf -n 1 "${ADDRESS_POOL_FILE}")
    echo "--interface ${ip}"
  else
    echo ""
  fi
}

function func_gen_youtube_dl_address_param() {
  if [[ "$ADDRESS_POOL" == "true" && "$ADDRESS_POOL_FILE" != "/dev/null" ]]; then
    local ip=$(shuf -n 1 "${ADDRESS_POOL_FILE}")
    echo "--source-address ${ip}"
  else
    echo ""
  fi
}

function func_gen_streamlink_address_param() {
  if [[ "$ADDRESS_POOL" == "true" && "$ADDRESS_POOL_FILE" != "/dev/null" ]]; then
    # Feb. 11, 2021
    # Changed my machine, toggling it back.
    # Feb. 8, 2021
    # IPv6 works not great on my machine, so let's fallback to IPv4 on streamlink.
    
    local ip=$(shuf -n 1 "${ADDRESS_POOL_FILE}")
    echo "--interface ${ip}"
    
    # echo "-4"
  else
    echo ""
  fi
}

function func_get_actual_video_url_of_live() {
  local _url=$1
  local regex="https:\/\/www.youtube.com\/channel\/(.+)\/live"
  if [[ "$_url" =~ $regex ]] ; then
    local CHANNEL_ID="${BASH_REMATCH[1]}"

    # Get video url
    local _url="https://www.youtube.com/embed/live_stream?channel=${CHANNEL_ID}"
    local regex='.+?<link rel="canonical" href="(.+)">.+'

    local address_param=$(func_gen_curl_address_param)
    local _body=$(curl $address_param -s --compressed -H "User-Agent: $USER_AGENT" "$_url")

    [[ "$_body" =~ $regex ]]
    local VIDEO_URL="${BASH_REMATCH[1]%%\"*}"
    echo "$VIDEO_URL"
  else
    echo "$_url"
  fi
}

function _gen_metadata_curl(){
  local _url=$1

  local address_param=$(func_gen_curl_address_param)
  if [ "$address_param" ]; then
    __info "using address: ${address_param##* }"
  fi
  local _body=$(curl $address_param -s --compressed -H "User-Agent: $USER_AGENT" "$_url")

  # NOTE: Dec 12, 2020
  echo "$_body" 2>/dev/null | grep -q "var ytInitialPlayerResponse" &> /dev/null
  local status=$?

  if [[ "$status" == "0" ]]; then
      # Extract metadata from fetched page
    METADATA_CURL=`echo "$_body" | grep -oP "var ytInitialPlayerResponse = \K.*(?=;</script>)" | jq -r .`
  else
    METADATA_CURL=""
    __debug "var ytInitialPlayerResponse returns null"
  fi
}

function func_check_state() {
  local _url=$1
  local _mode=$2

  __debug "start func_check_state"

  # Assume it's not a valid page, I use a custom state `invalid` here as initial state
  CONTENT_STATE="invalid"

  # Actually there's an official way to check if the streamer is live or not[^1] using YouTube
  # offical Data API, but it's costy that every search request costs you 100 credits. However
  # you can try it online[^2] to see how it works.
  #
  # If you have accounts that registered YouTube developer program before 2017, and has more
  # than 10 million credit quota, you can contact me t@sparanoid.com
  #
  # [1]: https://developers.google.com/youtube/v3/docs/search
  # [2]: https://developers.google.com/youtube/v3/code_samples/code_snippets

  # First check: use curl to check HTML pages for live state
  # Pros:
  # - Fast, no additional API requests compared to yt-dlp
  # - More ban-proof compared to yt-dlp
  # Cons:
  # - Can get wrong live state due to page caching, network interrupts, etc.
  _gen_metadata_curl "$_url"

  # Check if returns nothing
  if [ ! -z "$METADATA_CURL" ]; then
    __debug "Got valid cURL metadata"

    # At the time of writing, when `videoDetails.isLive` exists, it should be on live, when a video
    # is not live (normal videos, and even upcoming streams) this key will be missing and jq will
    # return `null`
    IS_LIVE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.isLive | select(.!=null)')
    __debug "Is live: $IS_LIVE"

    # 2021.01.01
    # if using the original $METADATA_CURL (Fetched by /live link), there's no .microformat.playerMicroformatRenderer exist
    # Causes issue when skip recheck is on.
    if [ "${IS_LIVE}" == "true" ]; then
      VIDEO_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.videoId')
      local _url="https://www.youtube.com/watch?v=${VIDEO_ID}"
      _gen_metadata_curl "$_url"
    fi

    # This status will always return:
    # - `OK` for live streams, private streams, or normal videos,
    # - `LIVE_STREAM_OFFLINE` for offline channel
    PLAYABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.status | select(.!=null)')
    __debug "Playability: $PLAYABILITY"

    # You will get some playability reasons for:
    # - `Offline` for streams are not live
    # - `This live event will begin in {n} hours.` for upcoming streams, you can also get specific
    #   UNIX timestamp with .scheduledStartTime (see below)
    # - `null` (this key will be missing) for:
    #   - On live streams or private streams
    #   - Non-streaming content
    PLAYABILITY_REASON=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.reason | select(.!=null)')
    __debug "Playability Reason: $PLAYABILITY_REASON"

    # When the streamer is streaming privately, this key will be empty
    STREAMABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.videoId | select(.!=null)')
    __debug "Streamability ID: $STREAMABILITY"

    # Get upcoming time when available
    # This key will be missing if no upcoming events available
    UPCOMING_TIME=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.offlineSlate.liveStreamOfflineSlateRenderer.scheduledStartTime | select(.!=null)')
    __debug "Scheduled Start Time: $UPCOMING_TIME"

    # Get some metadata first, I will retrieve more later using yt-dlp
    VIDEO_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.videoId')
    FULLTITLE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.title')
    DESCRIPTION=$(echo "$METADATA_CURL" | jq -r '.videoDetails.shortDescription')
    UPLOADER=$(echo "$METADATA_CURL" | jq -r '.videoDetails.author')
    CHANNEL_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.channelId')
    THUMBNAIL=$(echo "$METADATA_CURL" | jq -r '.videoDetails.thumbnail.thumbnails[-1].url')
    AVERAGE_RATING=$(echo "$METADATA_CURL" | jq -r '.videoDetails.averageRating')
    VIEW_COUNT=$(echo "$METADATA_CURL" | jq -r '.videoDetails.viewCount')
    UPLOAD_DATE=$(echo "$METADATA_CURL" | jq -r '.microformat.playerMicroformatRenderer.uploadDate')
    UPLOAD_DATE=${UPLOAD_DATE//-/}
    UPLOADER=$(echo "$METADATA_CURL" | jq -r '.microformat.playerMicroformatRenderer.ownerChannelName')
    CHANNEL_URL=$(echo "$METADATA_CURL" | jq -r '.microformat.playerMicroformatRenderer.ownerProfileUrl')
    WEBPAGE_URL="https://www.youtube.com/watch?v=${VIDEO_ID}"

    # If I got `isLive: true` in first check, let me assume it's live but I can't trust it so I
    # will do a secound check using yt-dlp later with this flag.
    if [ "$IS_LIVE" == "true" ]; then
      __info "cURL check seems goes live now, continue checking..."
      CONTENT_STATE="live"
    else
      # If `isLive` key not exists, check if it's a valid video (playable)
      if [ "$PLAYABILITY" == "OK" ]; then

        # Then check if it's a channel URL
        if [ "$DL_TYPE" == "channel" ]; then

          # Check if the streamer is streaming privately.
          if [ -z "$STREAMABILITY" ]; then
            __info "$(__yellow "/live redirects to /, event mode or streaming privately?")"
          fi
        else
          CONTENT_STATE="video"
        fi
      fi

      # Then check if the stream just goes offline
      if [ "$PLAYABILITY" == "LIVE_STREAM_OFFLINE" ]; then
        CONTENT_STATE="offline"

        # Check if upcoming event available
        if [ ! -z "$UPCOMING_TIME" ]; then
          __info "$(__yellow "Upcoming event detected: $UPCOMING_TIME")"
        fi
      fi
    fi

    # Print current state for first check
    __debug "Current state for first check: $(__yellow "$CONTENT_STATE")"
  fi

  # Old method:
  # if echo "$_body" | grep -q 'ytplayer'; then

  #   # Assume it's not a live streaming page
  #   IS_LIVE_CONTENT="false"

  #   # Actually there's an official way to check if the streamer is live or not[^1] using YouTube
  #   # offical Data API, but it's costy that every search request costs you 100 credits. However
  #   # you can try it online[^2] to see how it works.
  #   #
  #   # If you have accounts that registered YouTube developer program before 2017, and has more
  #   # than 10 million credit quota, you can contact me t@sparanoid.com
  #   #
  #   # [1]: https://developers.google.com/youtube/v3/docs/search
  #   # [2]: https://developers.google.com/youtube/v3/code_samples/code_snippets
  #   if echo "$_body" | grep 'ytplayer' | grep -q '\\"isLive\\":true'; then
  #     # Is live, break out of loop and continue to next step
  #     IS_LIVE_CONTENT="true"
  #     break
  #   fi

  #   # Also break out if the given URL is not a channel (probably a video or a playlist)
  #   # This extra check could avoid downloading an upcoming stream when then "isLive" check above
  #   # fails for some reason (like YouTube changes the `isLive` JSON key to something else)
  #   if ! [ "$DL_TYPE" == "channel" ]; then
  #     # This script now can also handle normal YouTube video, but there's no way to check if the
  #     # given URL is a normal video or an upcoming stream, so we can just break out of the loop
  #     # and fallback to yt-dlp to check whelter this URL is downloadable. And make sure it
  #     # only execute once.
  #     ONE_TIME="true"
  #     break
  #   fi

  # else
  #   __info "$(__yellow "Not a valid video page!")"
  #   __info "You may get this warning due to internet interruption, continue running"

  #   # NOTE: Although this is the natural logic to exit the program if we can't find specific
  #   # element on this page that means it's not a valid video page. But in some rare cases, the
  #   # original page may be down or unreachable for internet interruption or other network issues.
  #   # So I decide to let the script continue to execute because this script is mainly focused on
  #   # recording streams.

  #   # exit 1
  # fi

  # Second check: use `yt-dlp` to check live state
  # NOTE: please avoid adding additional paths in the -o (template) option, it doesn't work well
  # and conflicts with my custom directory setup!
  # I also need redirect stderr to stdout to catch any error during fetching URL
  # Pros:
  # - Accurate live state detection
  # Cons:
  # - Slow, yt-dlp will fire API requests to get more info it need to download videos
  # - Your IP can get banned easily when running in download or notifier mode due to large amount of
  #   API requests.
  if [ "$CONTENT_STATE" != "invalid" ]; then

    # Condition explain:
    # Only run second check when:
    # - The stream goes live that need a second check to ensure it's actually live
    # - The stream goes offline that need a second check to ensure it's actually offline
    if ([ "$CONTENT_STATE" != "offline" ] && [ "$_mode" != "lazy" ]) || \
      ([ "$CONTENT_STATE" == "offline" ] && [ "$_mode" == "lazy" ])
    then
      if [ "$SKIP_RECHECK" != "true" ]; then
        __info "Re-checking via yt-dlp..."

        local _url=$(func_get_actual_video_url_of_live "$_url")
        __info "Get real video url: $_url"
        local _youtube_dl_address_param=$(func_gen_youtube_dl_address_param)
        if [ "$_youtube_dl_address_param" ]; then
          __info "using address: ${_youtube_dl_address_param##* }"
        fi
        METADATA=`yt-dlp --ignore-config --no-playlist --playlist-items 0 \
          --skip-download --print-json --referer 'https://www.youtube.com/feed/subscriptions' \
          -o '%(upload_date)s %(title)s (%(id)s).%(ext)s' \
          ${_youtube_dl_address_param} \
          "$_url" 2>&1`

        # Check if returns nothing
        if [ ! -z "$METADATA" ]; then
          __debug "Got valid yt-dlp metadata"

          # Check if it's a valid JSON return
          if [[ "$METADATA" == '{'* ]]; then
            # Unlike other part of the jq checks, I ignore the `| select(.!=null)` to explicitly
            # return `null` to tell if it's a normal video or it just returns nothing
            local _is_live=`echo "$METADATA" | jq -r '.is_live'`

            # Parse metadata
            func_process_youtube_metadata

            # Map uploader name with pre-defined config
            func_process_channel_mapping

            # Finalize variables and paths then output summary
            func_finalize_vars

            if [ "$_is_live" == "true" ]; then
              __debug "Got state: live";
              CONTENT_STATE="live"
            elif [ "$_is_live" == "null" ]; then
              __debug "Got state: video";
              CONTENT_STATE="video"
            else
              __info "yt-dlp does not returns a valid state";
              CONTENT_STATE="invalid"
            fi
          else
            __debug "$METADATA"
            if [[ "$METADATA" =~ "This video is unavailable" ]]; then
              # Suppress `video is unavailable` errors since they're common when stream is not live
              __debug "This video is unavailable, maybe not live at the moment."
              CONTENT_STATE="unavailable"
            elif [[ "$METADATA" =~ "HTTP Error 404" ]]; then
              __info "$(__yellow "Not a valid video page (Error 404)!")"
              CONTENT_STATE="not_found"
            elif [[ "$METADATA" =~ "HTTP Error 429" ]]; then
              __info "$(__yellow "Your IP is limited by YouTube (Error 429)!")"
              CONTENT_STATE="too_many_requests"
            else
              __info "$(__yellow "Unknown metadata")"
              __info "$METADATA"
              CONTENT_STATE="invalid"
            fi
          fi
        else
          __info "$(__yellow "Second check failed, not valid yt-dlp metadata")"
          CONTENT_STATE="invalid"
        fi

        # Print current state for second check
        __debug "Current state for second check: $(__yellow "$CONTENT_STATE")"
      else
        func_process_youtube_metadata
        func_process_channel_mapping
        func_finalize_vars
      fi
    fi
  fi
}

function func_send_email() {
  local _title=$1
  local _content=$2

  if [ "$SKIP_EMAIL" != "true" ]; then

    if [ "$CONFIG_EMAIL_PROVIDER" == "mailgun" ]; then

      if [ "$CONFIG_MAILGUN_API" == "key-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No Mailgun credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        curl -s --user "api:$CONFIG_MAILGUN_API" \
          https://api.mailgun.net/v3/"$CONFIG_MAILGUN_DOMAIN"/messages \
          -F from="Livestream Downloader (live-dl) <live-dl@$CONFIG_MAILGUN_DOMAIN>" \
          -F to="$CONFIG_MAILGUN_RECEIPT" \
          -F subject="$_title" \
          -F text="$_content" >> "$OUTPUT_PATH.log" 2>&1
      fi
    fi

    if [ "$CONFIG_EMAIL_PROVIDER" == "ses" ]; then

      if [ "$CONFIG_SES_ACCESS" == "AKxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No AWS SES credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        local FROM="Livestream Downloader (live-dl) <live-dl@$CONFIG_SES_DOMAIN>"

        local ses_date="$(date -R)"
        # base64 different behavior alert:
        # https://stackoverflow.com/a/46464081/412385
        # Just use `base64` or `base64 -b 0` on macOS, on other platforms, use:
        # `base64 -w 0`
        local ses_signature="$(echo -n "$ses_date" | openssl dgst -sha256 -hmac "$CONFIG_SES_SECRET" -binary | base64)"
        local ses_auth_header="X-Amzn-Authorization: AWS3-HTTPS AWSAccessKeyId=$CONFIG_SES_ACCESS, Algorithm=HmacSHA256, Signature=$ses_signature"
        local ses_endpoint="https://email.us-east-1.amazonaws.com/"
        local ses_action="Action=SendEmail"
        local ses_source="Source=$FROM"
        local ses_to="Destination.ToAddresses.member.1=$TO"
        local ses_subject="Message.Subject.Data=$_title"
        local ses_message="Message.Body.Text.Data=$_content"

        curl -X POST -H "Date: $ses_date" -H "$ses_auth_header" \
          --data-urlencode "$ses_message" \
          --data-urlencode "$ses_to" \
          --data-urlencode "$ses_source" \
          --data-urlencode "$ses_action" \
          --data-urlencode "$ses_subject" \
          "$ses_endpoint" >/dev/null 2>&1
      fi
    fi
  fi
}

function func_send_slack() {
  local _type=$1

  if [ "$SKIP_SLACK" != "true" ]; then

    if [ "$CONFIG_SLACK_WEBHOOK" == "https://hooks.slack.com/services/" ]; then
      __info "$(__yellow "No Slack credentials found, skip sending Slack notification")"
    else
      __info "Sending Slack notification..."

      if [ "$_type" == "start" ]; then
        local _body='{
          "icon_emoji": ":red_circle:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      elif [ "$_type" == "stop" ]; then
        local _body='{
          "icon_emoji": ":black_square:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "Views",
                  "value": "'"$VIEW_COUNT"'",
                  "short": true
                },
                {
                  "title": "Likes",
                  "value": "'"$LIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Dislikes",
                  "value": "'"$DISLIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Average Rating",
                  "value": "'"$AVERAGE_RATING"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      else
        local _body='{
          "icon_emoji": ":ghost:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      fi

      curl -s -X POST -H 'Content-type: application/json' \
        -d "$_body" "$CONFIG_SLACK_WEBHOOK"
    fi
  fi
}

function func_send_telegram() {
  local _type=$1

  # https://core.telegram.org/bots/api
  if [ "$SKIP_TELEGRAM" != "true" ]; then

    if [ "$CONFIG_TELEGRAM_BOT" == "000000000:xxxxxxxxx" ]; then
      __info "$(__yellow "No Telegram credentials found, skip sending Telegram notification")"
    else
      if [ "$UPLOADER_TG_CHANNEL" ]; then
        __info "Sending Telegram notification..."
        local _time_start=$(TZ=":$UPLOADER_TIMEZONE" date +"%b %e %H:%M %Z (%z)")

        if [ "$_type" == "start" ]; then
          local _type="sendPhoto"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "photo": "'"$THUMBNAIL_CALC"'",
            "caption": "🔴 '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nStarts on '"$_time_start"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY_BASE$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        elif [ "$_type" == "stop" ]; then
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "⬛️ '"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nViews: '"$VIEW_COUNT"'\nLikes: '"$LIKE_COUNT"'\nDislikes: '"$DISLIKE_COUNT"'\nAverage Rating: '"$AVERAGE_RATING"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch finished stream", "url": "'"$WEBPAGE_URL"'"}
                ]
              ]
            },
            "disable_notification": true
          }'
        else
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "🔴 '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n'"$WEBPAGE_URL"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY_BASE$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        fi

        curl -s -X POST -H 'Content-Type: application/json' \
          -d "$_body" "https://api.telegram.org/bot$CONFIG_TELEGRAM_BOT/$_type"
      else
        __info "No specific channel set for current user, skip sending Telegram notification."
      fi
    fi
  fi
}

# Detect profile file if not specified as environment variable
# Borrowed from acme.sh
function func_detect_profile() {
  if [ -n "$PROFILE" -a -f "$PROFILE" ]; then
    echo "$PROFILE"
    return
  fi

  DETECTED_PROFILE=''
  SHELLTYPE="$(basename "/$SHELL")"

  if [ "$SHELLTYPE" = "bash" ]; then
    if [ -f "$HOME/.bashrc" ]; then
      DETECTED_PROFILE="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      DETECTED_PROFILE="$HOME/.bash_profile"
    fi
  elif [ "$SHELLTYPE" = "zsh" ]; then
    DETECTED_PROFILE="$HOME/.zshrc"
  fi

  if [ -z "$DETECTED_PROFILE" ]; then
    if [ -f "$HOME/.profile" ]; then
      DETECTED_PROFILE="$HOME/.profile"
    elif [ -f "$HOME/.bashrc" ]; then
      DETECTED_PROFILE="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      DETECTED_PROFILE="$HOME/.bash_profile"
    elif [ -f "$HOME/.zshrc" ]; then
      DETECTED_PROFILE="$HOME/.zshrc"
    fi
  fi

  echo "$DETECTED_PROFILE"
}

function remove_datetime_in_title {
  local org="$1"
  local regex="(.+)( [[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2} [[:digit:]]{2}[\:_][[:digit:]]{2})(.+)"

  if [[ "$org" =~ $regex ]]; then
    echo "${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
  else
    echo "$org"
  fi
}

function escape_filename {
  # Escape
  # https://support.microsoft.com/zh-tw/office/onedrive-%e5%92%8c-sharepoint-%e4%b8%ad%e7%84%a1%e6%95%88%e7%9a%84%e6%aa%94%e6%a1%88%e5%90%8d%e7%a8%b1%e5%92%8c%e6%aa%94%e6%a1%88%e9%a1%9e%e5%9e%8b-64883a5d-228e-48f5-b3d2-eb39e07630fa?ui=zh-tw&rs=zh-tw&ad=tw#invalidcharacters
  
  local filename="$1"
  filename="${filename//\"/_}"
  filename="${filename//\*/_}"
  filename="${filename//\:/_}"
  filename="${filename//\</_}"
  filename="${filename//\>/_}"
  filename="${filename//\?/_}"
  filename="${filename//\//_}"
  filename="${filename//\|/_}"
  echo "${filename}"
}

function func_process_youtube_metadata() {
  # Extract video info from JSON
  if [ "$SKIP_RECHECK" != "true" ]; then
    VIDEO_ID=$(echo "$METADATA" | jq -r '.id')
    # 2021.3.1
    # youtube-dl and its fork Changed its live stream title format (embed datetime into the title)
    # So we now deprecate getting title from youtube-dl unless we got nothing from curl
    if [[ -z "$FULLTITLE" ]]; then
      FULLTITLE=$(echo "$METADATA" | jq -r '.fulltitle')
      FULLTITLE=`remove_datetime_in_title "${FULLTITLE}"`
    fi
    DESCRIPTION=$(echo "$METADATA" | jq -r '.description')
    UPLOAD_DATE=$(echo "$METADATA" | jq -r '.upload_date')
    UPLOADER=$(echo "$METADATA" | jq -r '.uploader')
    CHANNEL_ID=$(echo "$METADATA" | jq -r '.channel_id')
    THUMBNAIL=$(echo "$METADATA" | jq -r '.thumbnail')
    WEBPAGE_URL=$(echo "$METADATA" | jq -r '.webpage_url')
    CHANNEL_URL=$(echo "$METADATA" | jq -r '.channel_url')
    VIEW_COUNT=$(echo "$METADATA" | jq -r '.view_count')
    LIKE_COUNT=$(echo "$METADATA" | jq -r '.like_count')
    DISLIKE_COUNT=$(echo "$METADATA" | jq -r '.dislike_count')
    AVERAGE_RATING=$(echo "$METADATA" | jq -r '.average_rating')

    # Filename (without path)
    # FILENAME=$(echo "$METADATA" | jq -r '._filename' | sed -e 's/.mp4//' | sed -e 's/.webm//')
  fi

  FULLTITLE=`escape_filename "${FULLTITLE}"`
  FILENAME="$UPLOAD_DATE $FULLTITLE ($VIDEO_ID)"
}

function func_process_channel_mapping() {
  # Find channel name mapping
  # https://stackoverflow.com/a/40027637/412385

  if [ "$CHANNEL_ID" ]; then
    UPLOADER_MAPPED_RAW=`echo "$CONFIG_RAW" | jq -r --arg CHANNEL_ID "$CHANNEL_ID" \
      '.map[] | select(.youtube | contains($CHANNEL_ID))'`

    # Check if current uploader has custom name mapping in config
    UPLOADER_MAPPED=`echo "$UPLOADER_MAPPED_RAW" | jq -r .name`

    if [ ! -z "${UPLOADER_MAPPED// }" ]; then
      __debug "Channel name mapping found: $(__yellow "$UPLOADER") → $(__green "$UPLOADER_MAPPED")"
      __debug "I will use $(__green "$UPLOADER_MAPPED") for folder name, embedding metadata, etc."
      UPLOADER="$UPLOADER_MAPPED"
    else
      __debug "Channel name mapping $(__yellow "not found"), consider adding it in config.yml"
      __debug "I will use $(__yellow "$UPLOADER") for folder name, embedding metadata, etc."
    fi

    # Check if current uploader has dedicated Telegram channel
    UPLOADER_TG_CHANNEL=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.telegram | select (.!=null)'`

    if [ "${UPLOADER_TG_CHANNEL}" ]; then
      __debug "Telegram channel found: $(__green "$UPLOADER_TG_CHANNEL")"
    else
      __debug "Telegram channel $(__yellow "not found"), consider adding it in config.yml"
    fi

    # Check if current uploader has custom timezone
    UPLOADER_TIMEZONE=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.timezone | select (.!=null)'`

    if [ -z "$UPLOADER_TIMEZONE" ]; then
      UPLOADER_TIMEZONE=`echo "$CONFIG_RAW" | jq -r '.config.timezone'`
    fi

  else
    __info "$(__red "Missing uploader ID!")"
    exit 1
  fi
}

function func_prepare_dir() {
  local _dir=$1
  [ -d "$_dir" ] || mkdir -p "$_dir"
}

function _touch(){
  local file=$1
  func_prepare_dir `dirname ${file}`
  touch "$file"
}

function func_create_file_name() {
  # Output $file_base_name.X if $file_base_name$EXTENSION exists.
  # prevents the 6hr overwrite issue.

  local file_base_name="${1:-$FILENAME}"
  local output_dir="${2:-$OUTPUT_BASE}"

  if [ -f "$output_dir/${file_base_name}${EXTENSION}" ] || \
     [ -f "$output_dir/${file_base_name}.mp4" ] || \
     [ -f "$output_dir/${file_base_name}.ts" ] || \
     [ -f "$output_dir/${file_base_name}.log" ] || \
     [ -f "$output_dir/${file_base_name}.jpg" ] || \
     [ -f "$output_dir/${file_base_name}.json" ] || \
     [ -f "$output_dir/${file_base_name}.tmp" ] || \
     [ -f "$output_dir/${file_base_name}.finished" ]
  then
    local -i NUM_POSTFIX=1
    while [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}${EXTENSION}" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.mp4" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.ts" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.log" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.jpg" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.json" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.tmp" ] || \
     [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}.finished" ]; do
      let NUM_POSTFIX+=1
    done
    _touch "$output_dir/${file_base_name}.${NUM_POSTFIX}.tmp"
    echo "${file_base_name}.${NUM_POSTFIX}"
  else
    _touch "$output_dir/${file_base_name}.tmp"
    echo $file_base_name
  fi
}

function func_finalize_vars() {
  # Output preffix dir (without user base dir)
  # Also I replace slash with underscores here to avoid nesting directories
  # i.e.
  # 天宮 こころ / Kokoro Amamiya 【にじさんじ所属】 will become:
  # 天宮 こころ／Kokoro Amamiya 【にじさんじ所属】
  EXTENSION=".ts"
  FILENAME_BASE=$(echo "$UPLOADER" | sed "s/\//／/" | sed "s/ ／ /／/")

  # Output base without filename
  OUTPUT_BASE="$BASE_DIR/$FILENAME_BASE"
  func_prepare_dir "$OUTPUT_BASE"

  # Full output dir
  FILENAME=$(func_create_file_name "$FILENAME" "$OUTPUT_BASE")
  OUTPUT_PATH="$OUTPUT_BASE/$FILENAME"

  # Write prettified JSON metadata to file
  if [ "$SKIP_RECHECK" != "true" ]; then
    METADATA_PRETTIFIED=`echo $METADATA | jq .`
  else
    METADATA_PRETTIFIED=`echo ${METADATA_CURL} | jq .`
  fi
  echo "$METADATA_PRETTIFIED" > "$OUTPUT_PATH.json"
  rm "$OUTPUT_PATH.tmp"

  # Download thumbnail
  # yt-dlp has built-in thumbnail download feature via --write-all-thumbnails but it's not
  # perfect due to the limitation of YouTube API, yt-dlp will only get `hqdefault.jpg` for
  # finished streams (live streams not affected) because offical API only returns this size even
  # higher resolution is available (`maxresdefault.jpg`). So I created some additional checks here.
  #
  # For stream content, YouTube provides both `maxresdefault.jpg` and `maxresdefault_live.jpg`, but
  # `maxresdefault.jpg` is more reliable as `maxresdefault_live.jpg` will return black image
  # (200 HTTP code) even if the streamer set a smaller thumbnail that is only suitable at a smaller
  # size (hqdefault.jpg)
  #
  # Another scenario is that that the streamer set an upcoming event with thumbnail-A, and she/he
  # later changes it to another (thumbnail-B) when stream goes live, `maxresdefault_live.jpg` seems
  # always returns thumbnail-A while `maxresdefault.jpg` can get the correct thumbnail-B.
  #
  # First download thumbnail provided from yt-dlp
  THUMBNAIL_CALC="$THUMBNAIL"
  curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"

  # Check thumbnail width
  THUMB_W=`exiv2 "$OUTPUT_PATH.jpg" | awk -F: '/Image size/ {print $2}' | cut -dx -f1 | tr -d ' '`
  if [ "$THUMB_W" -lt "1280" ]; then
    __info "Thumbnail ($THUMBNAIL_CALC) downloeded via yt-dlp is too small, try our own method"

    # Re-assign thumbnail URL
    THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/maxresdefault.jpg"

    # Check if thumbnail is available (has 200 HTTP response code)
    local _thumb_resp=$(curl -qSsfw "%{http_code}" $THUMBNAIL_CALC -o /dev/null)

    if [ "$_thumb_resp" != "200" ]; then
      __info "No high-res thumbnial (maxresdefault.jpg), failback to hqdefault.jpg"
      THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/hqdefault.jpg"
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    else
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    fi
  fi

  # Output summary
  SUMMARY="ID:        $VIDEO_ID
Title:     $FULLTITLE
URL:       $WEBPAGE_URL
Author:    $UPLOADER
Channel:   $CHANNEL_URL
Date:      $UPLOAD_DATE
Thumbnail: $THUMBNAIL_CALC
Filename:  $FILENAME
Location:  $OUTPUT_BASE/
Hostname:  $HOSTNAME
"

  # Trim additional whitespace, used by email body
  SUMMARY_TRIM=`echo "$SUMMARY" | perl -pe 's/: +/: /g'`
}

function func_download_youtube() {
  __info "Start downloading $FILENAME"

  # Log tail inspired by https://github.com/printempw/live-stream-recorder
  __info "Logging: tail -f \"$OUTPUT_PATH.log\""

  if [ "$CONTENT_STATE" == "live" ]; then
    if [[ $YTARCHIVE == "true" ]] && [[ $YTARCHIVE_EXEC != "/dev/null" ]]; then
      # % Has a special meaning in python
      local tmp_output_path="${OUTPUT_PATH//%/%%}"

      if [[ "$YTARCHIVE_COOKIE" != "/dev/null" ]] && [[ -f "$YTARCHIVE_COOKIE" ]]; then
        local ytarchive_cookie_param="-c \"$YTARCHIVE_COOKIE\""
      else
        local ytarchive_cookie_param=""
      fi
      mkdir -p /tmp/ytarchive
      (cd /tmp/ytarchive && "$YTARCHIVE_EXEC" \
        --no-wait \
        --vp9 \
        ${ytarchive_cookie_param} \
        -o "${tmp_output_path}" \
        "${WEBPAGE_URL}" best) >> "$OUTPUT_PATH.log" 2>&1
    else
      local _streamlink_address_param=$(func_gen_streamlink_address_param)
      if [ "$_streamlink_address_param" ]; then
        __info "using address: ${_streamlink_address_param##* }"
      fi
      streamlink \
        ${_streamlink_address_param} \
        --force \
        --hls-live-restart \
        --hls-segment-threads 10 \
        --hls-segment-attempts 5 \
        --hls-segment-ignore-names preloading \
        --ringbuffer-size 256M \
        --loglevel trace \
        -o "${OUTPUT_PATH}${EXTENSION}" \
        "${WEBPAGE_URL}" best >> "$OUTPUT_PATH.log" 2>&1
    fi
  elif [ "$CONTENT_STATE" == "video" ]; then
    if [ "$DL_TYPE" == "playlist" ]; then
      # TODO: You have to loop over all the videos to add metadata and thumbnail manually.
      # Or you can add the following parameters to handle it using yt-dlp automatically:
      #   --embed-thumbnail # requires AtomicParsley
      #   --add-metadata
      yt-dlp \
        --ignore-config \
        --download-archive archive.txt \
        --embed-thumbnail \
        --add-metadata \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' \
        --write-auto-sub \
        --write-sub \
        --sub-lang en,zh-Hans,zh-Hant,ja \
        --sub-format best \
        --embed-subs \
        --retries 30 \
        -o "${OUTPUT_BASE}/%(upload_date)s %(title)s (%(id)s).%(ext)s" \
        "${WEBPAGE_URL}"
    else
      yt-dlp \
        --ignore-config \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' \
        --write-auto-sub \
        --write-sub \
        --sub-lang en,zh-Hans,zh-Hant,ja \
        --sub-format best \
        --retries 30 \
        -o "${OUTPUT_BASE}/%(upload_date)s %(title)s (%(id)s).%(ext)s" \
        "${WEBPAGE_URL}"
    fi
  else
    __info "Not a valid URL, skippping"
  fi
}

function func_download_bilibili() {
  __info "bilibili download func"
}

function func_finalize_download() {
  __info "Stop downloading"

  if [ "$CONTENT_STATE" == "live" ]; then
    if [[ $YTARCHIVE == "true" ]] && [[ $YTARCHIVE_EXEC != "/dev/null" ]]; then
      __info "Using ytarchive, skipping convert to MP4."
    else
      # Convert from TS to MP4 (will override existing with -y option)
      __info "Converting to MP4"
      ffmpeg -i "${OUTPUT_PATH}${EXTENSION}" -y \
        -codec copy \
        -movflags faststart \
        "$OUTPUT_PATH.mp4" >> "$OUTPUT_PATH.log" 2>&1

      # Remove original TS file
      rm -f "${OUTPUT_PATH}${EXTENSION}"
    fi
  fi

  if [ ! "$SKIP_METADATA" ]; then
    __info "Trying to write metadata and artwork"

    # Write metadata to MP4 (will override existing with -y option)
    if [ -f "$OUTPUT_PATH.mp4" ]; then
      __info "Writing metadata"
      ffmpeg -i "$OUTPUT_PATH.mp4" -y \
        -codec copy \
        -metadata title="$FULLTITLE" \
        -metadata artist="$UPLOADER" \
        -metadata date="$UPLOAD_DATE" \
        -metadata description="$DESCRIPTION" \
        -metadata comment="$DESCRIPTION" \
        -movflags faststart \
        "$OUTPUT_PATH-metadata.mp4" >> "$OUTPUT_PATH.log" 2>&1
      rm -f "$OUTPUT_PATH.mp4" && mv "$OUTPUT_PATH-metadata.mp4" "$OUTPUT_PATH.mp4"
    else
      __info "$(__yellow "Output file not exists, skip writing metadata.")"
    fi

    # Writing artwork cover
    # I have to emabed artwork and metadata in two separate steps be cause FFmpeg can't pipe these
    # two steps into one. And AtomicParsley also doesn't support medatada in-file writing.
    if [ -f "$OUTPUT_PATH.mp4" ]; then
      __info "Writing artwork"

      # Check if artwork avaiable
      if [ -f "$OUTPUT_PATH.jpg" ]; then
        ffmpeg -i "$OUTPUT_PATH.mp4" -y \
          -i "$OUTPUT_PATH.jpg" \
          -map 1 -map 0 \
          -codec copy \
          -disposition:0 attached_pic \
          -movflags faststart \
          "$OUTPUT_PATH-artwork.mp4" >> "$OUTPUT_PATH.log" 2>&1
        rm -f "$OUTPUT_PATH.mp4" && mv "$OUTPUT_PATH-artwork.mp4" "$OUTPUT_PATH.mp4"
      else
        __info "$(__yellow "Artwork missing, this is a rare case, please report at my GitHub.")"
      fi
    else
      __info "$(__yellow "Output file not exists, skip embedding artwork.")"
    fi
  fi

  # Get file summary for later use
  if [ -f "$OUTPUT_PATH.mp4" ]; then
    DOWNLOADED_FILE_SUMMARY=`ffprobe -i \
      "$OUTPUT_PATH.mp4" \
      -v quiet \
      -print_format json \
      -show_format \
      -show_streams \
      -hide_banner`

    FILE_SUMMARY_DURATION=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .streams[0].duration`
    FILE_SUMMARY_DURATION_INIT=${FILE_SUMMARY_DURATION%.*}
    FILE_SUMMARY_DURATION_CALC=$(__convert_seconds $FILE_SUMMARY_DURATION_INIT)
    FILE_SUMMARY_SIZE=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .format.size`
    FILE_SUMMARY_SIZE_CALC=$(numfmt --to=iec-i --suffix=B $FILE_SUMMARY_SIZE)
    FILE_SUMMARY="Duration:  $FILE_SUMMARY_DURATION_CALC
Size:      $FILE_SUMMARY_SIZE_CALC
Path:      $HOSTNAME:$OUTPUT_PATH.mp4
" && echo -e "\n$FILE_SUMMARY"
  else
    FILE_SUMMARY="File summary not available due to missing files"
    __info "$(__yellow "File summary not available due to missing files.")"
  fi

  # Trim additional whitespace, used by email body
  FILE_SUMMARY_TRIM=`echo "$FILE_SUMMARY" | perl -pe 's/: +/: /g'`

  # Additional sleep to ensure the stream is stopped on YouTube frontend, you can also increase
  # --hls-timeout to make sure the streamer correctly stops the stream, but the longer the
  # --hls-timeout you set, the longer the notification you will get after the streamer actually
  # stops his/her stream.
  sleep 10
}

function func_callback() {
  if [ $CALLBACK == "true" ]; then
    if [ $CALLBACK_EXEC != "/dev/null" ]; then 
      __info "Calling callback function..."
      local cmd=( "$CALLBACK_EXEC" "${OUTPUT_PATH}.mp4" "$BASE_DIR/" "$VIDEO_ID" "$FULLTITLE" "$UPLOADER" "$UPLOAD_DATE" "$THUMBNAIL_CALC" )
      nohup "${cmd[@]}" &>> "$OUTPUT_PATH.log" &
    else
      __info "$(__yellow "No callback executable specified.")"
    fi
  fi
}

function func_onlive() {
  if [ $ONLIVE == "true" ]; then
    if [ $ONLIVE_EXEC != "/dev/null" ]; then 
      __info "Calling onlive function..."
      local cmd=( "$ONLIVE_EXEC" "${OUTPUT_PATH}" "$BASE_DIR/" "$VIDEO_ID" "$FULLTITLE" "$UPLOADER" "$UPLOAD_DATE" "$THUMBNAIL_CALC" )
      nohup "${cmd[@]}" &>> "$OUTPUT_PATH.log" &
    else
      __info "$(__yellow "No onlive executable specified.")"
    fi
  fi
}

#
# Executes
#

# Init scripts with `--init` specified
INIT_SCRIPT="${PARAM_INIT_SCRIPT:-"false"}"
if [ "$INIT_SCRIPT" == "true" ]; then
  func_check_deps
  exit 0
fi

# Print usage if no URL passed
if [ ! -n "$1" ]; then
  echo "Usage: $0 url [options]

Run $0 --init to initialize this script.

Examples:
  Monitor specific channel, download stream when channel goes live:
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg/live
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  live-dl UC1opHUrw8rvnsadT-iGp7Cg

  Download specific upload, this should be a live stream or finished stream
  live-dl https://www.youtube.com/watch?v=S3CAGeeMRvo
  live-dl S3CAGeeMRvo

  Download all uploads from a playlist
  live-dl https://www.youtube.com/playlist?list=UU1opHUrw8rvnsadT-iGp7Cg

Options:
  --mode, -m                  Running mode, default: download, available: metadata, notifier
  --output, -o                Base output directory, default: ~/Downloads
  --interval, -i              Loop interval, unit: second, default: 10
  --create-alias, -a          Create program alias to your current shell profile
  --skip-check, -c            Skip dependency check, default: false
  --skip-recheck              Skip 2nd stage yt-dlp live check, default: false
  --skip-convert              Skip converting TS file to MP4
  --skip-email                Skip sending email notification
  --skip-slack                Skip sending Slack notification
  --skip-telegram             Skip sending Telegram notification
  --callback [EXECUTABLE]     Run the callback after videos downloaded
  --onlive [EXECUTABLE]       Run the executable before livestream starts downloading
  --ytarchive [EXECUTABLE]    Downloads livestream using ytarchive instead of streamlink
  --ytarchive-cookie [FILE]   Use cookie file for ytarchive download
  --address-pool [list.txt]   Use multiple addresses for curl to prevent 429 Error          
  --once, -1                  Run only once, default: false
  --debug                     Show debug logs, default: false
  --image-proxy               Enable image proxy for China users, default: false"
  exit 1
fi

# Check if we have config.yml
if ! [ -f config.yml ]; then
  __info "$(__red "No config.yml, 'cp config.example.yml config.yml' and rerun this script.")"
  exit 1;
else
  CONFIG_RAW=`cat config.yml | yq -r .`
fi

# Set default settings

# Remove trailing slash for user defined directory
# https://stackoverflow.com/a/1848456/412385
_PARAM_BASE_DIR=${PARAM_BASE_DIR%/*}

# Expand $HOME so that later I can replace `~` with escaped $HOME path in `config.yml`
HOME_EXPANDED=$(echo "$HOME" | sed -e 's/\//\\\//g')

CONFIG_MODE=`echo $CONFIG_RAW | jq -r '.config.mode | select(.!=null)'`
CONFIG_BASE_DIR=`echo $CONFIG_RAW | jq -r .config.output | sed -e 's/~/'"$HOME_EXPANDED"'/g'`
CONFIG_INTERVAL=`echo $CONFIG_RAW | jq -r '.config.interval | select(.!=null)'`
CONFIG_SKIP_RECHECK=`echo $CONFIG_RAW | jq -r '.config.skip_recheck | select(.!=null)'`
CONFIG_SKIP_CONVERT=`echo $CONFIG_RAW | jq -r '.config.skip_convert | select(.!=null)'`
CONFIG_SKIP_METADATA=`echo $CONFIG_RAW | jq -r '.config.skip_metadata | select(.!=null)'`
CONFIG_SKIP_EMAIL=`echo $CONFIG_RAW | jq -r '.config.skip_email | select(.!=null)'`
CONFIG_SKIP_SLACK=`echo $CONFIG_RAW | jq -r '.config.skip_slack | select(.!=null)'`
CONFIG_SKIP_TELEGRAM=`echo $CONFIG_RAW | jq -r '.config.skip_telegram | select(.!=null)'`
CONFIG_CALLBACK=`echo $CONFIG_RAW | jq -r '.config.run_callback | select(.!=null)'`
CONFIG_ONLIVE=`echo $CONFIG_RAW | jq -r '.config.run_onlive | select(.!=null)'`
CONFIG_YTARCHIVE=`echo $CONFIG_RAW | jq -r '.config.use_ytarchive | select(.!=null)'`
CONFIG_ADDRESS_POOL=`echo $CONFIG_RAW | jq -r '.config.address_pool | select(.!=null)'`
CONFIG_ONE_TIME=`echo $CONFIG_RAW | jq -r '.config.one_time | select(.!=null)'`
CONFIG_IMAGE_PROXY=`echo $CONFIG_RAW | jq -r '.config.image_proxy | select(.!=null)'`
CONFIG_EMAIL_PROVIDER=`echo $CONFIG_RAW | jq -r '.config.email_provider | select(.!=null)'`
CONFIG_MAILGUN_API=`echo $CONFIG_RAW | jq -r '.config.mailgun.api | select(.!=null)'`
CONFIG_MAILGUN_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.mailgun.domain | select(.!=null)'`
CONFIG_MAILGUN_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.mailgun.receipt | select(.!=null)'`
CONFIG_SES_ACCESS=`echo $CONFIG_RAW | jq -r '.config.ses.access | select(.!=null)'`
CONFIG_SES_SECRET=`echo $CONFIG_RAW | jq -r '.config.ses.secret | select(.!=null)'`
CONFIG_SES_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.ses.domain | select(.!=null)'`
CONFIG_SES_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.ses.receipt | select(.!=null)'`
CONFIG_SLACK_WEBHOOK=`echo $CONFIG_RAW | jq -r '.config.slack.webhook | select(.!=null)'`
CONFIG_TELEGRAM_BOT=`echo $CONFIG_RAW | jq -r '.config.telegram.bot | select(.!=null)'`
CONFIG_TELEGRAM_CHANNEL=`echo $CONFIG_RAW | jq -r '.config.telegram.channel | select(.!=null)'`
CONFIG_CALLBACK_EXEC=`echo $CONFIG_RAW | jq -r '.config.callback.executable | select(.!=null)'`
CONFIG_ONLIVE_EXEC=`echo $CONFIG_RAW | jq -r '.config.onlive.executable | select(.!=null)'`
CONFIG_YTARCHIVE_EXEC=`echo $CONFIG_RAW | jq -r '.config.ytarchive.executable | select(.!=null)'`
CONFIG_YTARCHIVE_COOKIE=`echo $CONFIG_RAW | jq -r '.config.ytarchive.cookie | select(.!=null)'`
CONFIG_ADDRESS_POOL_FILE=`echo $CONFIG_RAW | jq -r '.config.address_pool_file | select(.!=null)'`

MODE="${PARAM_MODE:-$CONFIG_MODE}"
BASE_DIR="${_PARAM_BASE_DIR:-$CONFIG_BASE_DIR}"
INTERVAL="${PARAM_INTERVAL:-$CONFIG_INTERVAL}"
SKIP_CONVERT="${PARAM_SKIP_CONVERT:-$CONFIG_SKIP_CONVERT}"
SKIP_RECHECK="${PARAM_SKIP_RECHECK:-$CONFIG_SKIP_RECHECK}"
SKIP_METADATA="${PARAM_SKIP_METADATA:-$CONFIG_SKIP_METADATA}"
SKIP_EMAIL="${PARAM_SKIP_EMAIL:-$CONFIG_SKIP_EMAIL}"
SKIP_SLACK="${PARAM_SKIP_SLACK:-$CONFIG_SKIP_SLACK}"
SKIP_TELEGRAM="${PARAM_SKIP_TELEGRAM:-$CONFIG_SKIP_TELEGRAM}"
CALLBACK="${PARAM_CALLBACK:-$CONFIG_CALLBACK}"
CALLBACK_EXEC="${PARAM_CALLBACK_EXEC:-$CONFIG_CALLBACK_EXEC}"
ONLIVE="${PARAM_ONLIVE:-$CONFIG_ONLIVE}"
ONLIVE_EXEC="${PARAM_ONLIVE_EXEC:-$CONFIG_ONLIVE_EXEC}"
YTARCHIVE="${PARAM_YTARCHIVE:-$CONFIG_YTARCHIVE}"
YTARCHIVE_EXEC="${PARAM_YTARCHIVE_EXEC:-$CONFIG_YTARCHIVE_EXEC}"
YTARCHIVE_COOKIE="${PARAM_YTARCHIVE_COOKIE:-$CONFIG_YTARCHIVE_COOKIE}"
ADDRESS_POOL="${PARAM_ADDRESS_POOL:-$CONFIG_ADDRESS_POOL}"
ADDRESS_POOL_FILE="${PARAM_ADDRESS_POOL_FILE:-$CONFIG_ADDRESS_POOL_FILE}"
ONE_TIME="${PARAM_ONE_TIME:-$CONFIG_ONE_TIME}"
IMAGE_PROXY="${PARAM_IMAGE_PROXY:-$CONFIG_IMAGE_PROXY}"
URL_INPUT="$1"

if [ "IMAGE_PROXY" != "true" ]; then
  IMAGE_PROXY_BASE=""
fi

# Print current variables for reference
__info "URL (URI) to process           : ${URL_INPUT}"
__info "Mode                           : ${MODE}"
__info "Output base dir                : ${BASE_DIR}"
__info "Run interval (when loop)       : ${INTERVAL}"
__info "Skip convert                   : ${SKIP_CONVERT}"
__info "Skip recheck                   : ${SKIP_RECHECK}"
__info "Skip embedding metadata        : ${SKIP_METADATA}"
__info "Skip email notification        : ${SKIP_EMAIL}"
__info "Skip Slack notification        : ${SKIP_SLACK}"
__info "Skip Telegram notification     : ${SKIP_TELEGRAM}"
__info "Callback                       : ${CALLBACK}"
__info "Onlive                         : ${ONLIVE}"
__info "ytarchive                      : ${YTARCHIVE}"
__info "Address Pool                   : ${ADDRESS_POOL}"
__info "Email provider                 : ${CONFIG_EMAIL_PROVIDER}"
__info "One-time execution             : ${ONE_TIME}"

# Process URL from user parameter
func_create_url "$URL_INPUT"

# Main loop
while true; do
  __info "Checking $DL_URL..."

  # Monitor live streams of specific channel
  while true; do
    # Check if url types and live available
    # After creating URL with func_create_url, I need to further process the URL to determine
    # the type (video, live stream) and state (is live or not ) of the given URL
    func_check_state "$DL_URL"

    if [ "$CONTENT_STATE" == "live" ]; then
      break
    elif [ "$CONTENT_STATE" == "video" ]; then
      ONE_TIME="true"
      break
    else
      __debug "Not valid at the moment, continue running"
    fi

    __info "No streaming yet, retry in ${INTERVAL}s..."
    sleep $INTERVAL
  done

  # Get video(s) metadata
  __info "Fetching metadata..."
  __debug "Download platform: $DL_PLATFORM"
  __debug "Download type: $DL_TYPE"
  __debug "Download mode: $MODE"

  #
  # Platform: YouTube
  #
  if [ "$DL_PLATFORM" == "YouTube" ]; then
    # Print summary
    echo -e "\n$SUMMARY"

    #
    # Type: YouTube channel
    #
    if [ "$DL_TYPE" == "channel" ]; then

      #
      # Mode: download
      #
      if [ "$MODE" == "download" ]; then
        # Send notifications
        # https://stackoverflow.com/a/49819711/412385
        _break=$'\n\n'
        func_send_email "🔴 [YouTube] $UPLOADER - $FULLTITLE" "$SUMMARY_TRIM$_break$DESCRIPTION" &
        func_send_slack "start" &
        func_send_telegram "start" &
        func_onlive &
        func_download_youtube
        {
          func_finalize_download
          func_send_email "⚫️ [YouTube] $UPLOADER - $FULLTITLE" "$FILE_SUMMARY_TRIM" &
          func_callback
        } &

      #
      # Mode: metadata only
      #
      elif [ "$MODE" == "metadata" ]; then
        __info "Metadata only mode, no video will be downloaded."
        exit 0

      #
      # Mode: notifier
      #
      elif [ "$MODE" == "notifier" ]; then
        func_send_slack "start"
        func_send_telegram  "start"
        __info "Notifier mode, no video will be downloaded, continue monitoring..."

        while true; do
          func_check_state "$DL_URL" "lazy"

          if [ "$CONTENT_STATE" == "unavailable" ]; then
            __info "Live stopped"
            func_send_slack "stop"
            func_send_telegram "stop"
            break
          fi

          __info "Still streaming, retry in ${INTERVAL}s..."
          sleep $INTERVAL
        done

      #
      # Mode: unknown
      #
      else
        __info "$(__red "Unknown mode, check your config")"
        exit 1
      fi

    #
    # Type: YouTube video
    #
    elif [ "$DL_TYPE" == "video" ]; then

      if [ "$MODE" == "download" ]; then
        func_download_youtube
        func_finalize_download
        func_callback
        exit 0
      else
        __info "Metadata only mode, no video will be downloaded."
        exit 0
      fi

    #
    # Type: YouTube playlist
    #
    elif [ "$DL_TYPE" == "playlist" ]; then
      __info "Type: YouTube playlist"

    #
    # Type: Unknown
    #
    else
      __info "Type: Unknown"
    fi

  elif [ "$DL_PLATFORM" == "bilibili" ]; then
    __info "Download platform: Bilibili"
  else
    __info "Download platform: Unknown"
  fi

  # Break current loop if only run once
  [ "$ONE_TIME" == "true" ] && break
done
